/* The following code was generated by JFlex 1.4 on 10/20/17 10:48 AM */

/* You do not need to change anything up here. */


import {JavaFileReader} from '../../backend/libs/JavaFileReader';
import {isUndefined} from 'util';
import {Token} from './Token';
import {Type} from './Type';

/**
 * This class is a scanner generated by
 * <a href="http://www.jflex.de/">JFlex</a> 1.4
 * on 10/20/17 10:48 AM from the specification file
 * <tt>D:/Drive/CZ3007 - Compiler Techniques/CZ3007 - Compiler
 * Techniques/Lab/CZ3007Lab/lab1/Lab1/src/frontend/lexer.flex</tt>
 */
export class Lexer {
  
  /**
   * This character denotes the end of file
   */
  public static YYEOF = -1;
  /**
   * lexical states
   */
  public static YYINITIAL = -1;
  /**
   * initial size of the lookahead buffer
   */
  public static ZZ_BUFFERSIZE = -1;
  /**
   * Translates characters to character classes
   */
  public static ZZ_CMAP_PACKED = '';
  
  /**
   * Translates characters to character classes
   */
  public static ZZ_CMAP = Lexer.zzUnpackCMap(Lexer.ZZ_CMAP_PACKED);
  
  /**
   * Translates DFA states to action switch labels.
   */
  public static ZZ_ACTION_PACKED_0 = '';
  public static ZZ_ACTION: number[] = Lexer.zzUnpackAction();
  
  
  /**
   * Translates a state to a row index in the transition table
   */
  public static ZZ_ROWMAP_PACKED_0 = '';
  public static ZZ_ROWMAP = Lexer.zzUnpackRowMap();
  
  /**
   * The transition table of the DFA
   */
  public static ZZ_TRANS_PACKED_0 = '';
  public static ZZ_TRANS = Lexer.zzUnpackTrans();
  
  /* error codes */
  public static ZZ_UNKNOWN_ERROR = -1;
  public static ZZ_NO_MATCH = -1;
  public static ZZ_PUSHBACK_2BIG = -1;
  /* error messages for the codes above */
  public static ZZ_ERROR_MSG = [
    'Unkown internal scanner error',
    'Error: could not match input',
    'Error: pushback value was too large',
  ];
  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  public static ZZ_ATTRIBUTE_PACKED_0 = '';
  public static ZZ_ATTRIBUTE = Lexer.zzUnpackAttribute();
  private static ZZ_INTERVAL_LENGTH: number = -1;
  /**
   * the input device
   */
  public zzReader: JavaFileReader;

// public static zzUnpackAttribute(): number[] {
//
//   let offset = 0;
//   const result = Lexer.zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, offset);
//   return result;
  /**
   * the current state of the DFA
   */
  public zzState = -1;
// }
  /**
   * the current lexical state
   */
  public zzLexicalState = -1;
  /**
   * this buffer contains the current text to be matched and is
   * the source of the yytext() string
   */
  public zzBuffer = '';
  /**
   * the textposition at the last accepting state
   */
  public zzMarkedPos;
  /**
   * the textposition at the last state to be included in yytext
   */
  public zzPushbackPos = -1;
  /**
   * the current text position in the buffer
   */
  public zzCurrentPos = -1;
  /**
   * startRead marks the beginning of the yytext() string in the buffer
   */
  public zzStartRead = -1;
  /**
   * endRead marks the last character in the buffer, that has been read
   * from input
   */
  public zzEndRead = -1;
  /**
   * number of newlines encountered up to the start of the matched text
   */
  public yyline = -1;
  /**
   * the number of characters up to the start of the matched text
   */
  public yychar = -1;
  /**
   * the number of characters from the last newline up to the start of the
   * matched text
   */
  public yycolumn = -1;
  /**
   * zzAtBOL == true <=> the scanner is currently at the beginning of a line
   */
  public zzAtBOL = false;
  /**
   * zzAtEOF == true <=> the scanner is at the EOF
   */
  public zzAtEOF = false;
  
  public static zzUnpackAction (packed?: string, offset?: number): number[] {
    if (isUndefined(packed)) {
      let result = [];
      offset = 0;
      result = Lexer.zzUnpackAction(Lexer.ZZ_ACTION_PACKED_0, offset);
      return result;
    }
    const result = [];
    let i = 0;
    /* index in packed string  */
    let j = offset;
    /* index in unpacked array */
    const l = packed.length;
    while (i < l) {
      let count = packed.charCodeAt(i++);
      const value = packed.charAt(i++);
      do {
        result[j++] = value;
      } while (--count > 0);
    }
    return result;
  }
  
  public static zzUnpackRowMap (packed?: string, offset?: number): number[] {
    if (isUndefined(packed)) {
      let result = [];
      offset = 0;
      result = Lexer.zzUnpackRowMap(Lexer.ZZ_ROWMAP_PACKED_0, offset);
      return result;
    }
    const result = [];
    let i = 0;
    /* index in packed string  */
    let j = offset;
    /* index in unpacked array */
    const l = packed.length;
    while (i < l) {
      const high = packed.charCodeAt(i++) << 16;
      result[j++] = high | packed.charCodeAt(i++);
    }
    return result;
  }
  
  public static zzUnpackTrans (packed?: string, offset?: number): number[] {
    if (isUndefined(packed)) {
      offset = 0;
      const result = Lexer.zzUnpackTrans(Lexer.ZZ_TRANS_PACKED_0, offset);
      return result;
      
    }
    
    
    const result = [];
    let i = 0;
    /* index in packed string  */
    let j = offset;
    /* index in unpacked array */
    const l = packed.length;
    while (i < l) {
      let count = packed.charCodeAt(i++);
      let value = packed.charCodeAt(i++);
      value--;
      do {
        result[j++] = value;
      } while (--count > 0);
    }
    return result;
  }
  
  public static zzUnpackAttribute (packed?: string, offset?: number): number[] {
    if (isUndefined(packed)) {
      offset = 0;
      const result = Lexer.zzUnpackAttribute(Lexer.ZZ_ATTRIBUTE_PACKED_0, offset);
      return result;
      
    }
    
    const result = [];
    let i = 0;
    /* index in packed string  */
    let j = offset;
    /* index in unpacked array */
    const l = packed.length;
    while (i < l) {
      let count = packed.charCodeAt(i++);
      const value = packed.charCodeAt(i++);
      do {
        result[j++] = value;
      } while (--count > 0);
    }
    return result;
  }
  
  /* user code: */
  
  /* These two methods are for the convenience of rules to create toke objects.
  * If you do not want to use them, delete them
  * otherwise add the code in
  */
  
  /**
   * Unpacks the compressed character translation table.
   *
   * @param packed the packed character translation table
   * @return the unpacked character translation table
   */
  public static zzUnpackCMap (packed: string): string {
    let map = '';
    let i = 0;
    /* index in packed string  */
    const j = 0;
    /* index in unpacked array */
    while (i < 126) {
      let count = packed.charCodeAt(i++);
      const value = packed.charAt(i++);
      do {
        map += value;
      } while (--count > 0);
    }
    return map;
  }
  
  /* Use this method for rules where you need to process yytext() to get the lexeme of the token.
   *
   * Useful for string literals; e.g., the quotes around the literal are part of yytext(),
   *       but they should not be part of the lexeme.
  */
  
  
  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param in the java.io.Reader to read input from.
   */
// public constructor(in: JavaFileReader) {
//   this.zzReader = in;
// }
  
  /**
   * Creates a new scanner.
   * There is also java.io.Reader version of this constructor.
   *
   * @param in the java.io.Inputstream to read input from.
   */
// public Lexer(java.io.InputStream in) {
//   this(new java.io.InputStreamReader(in));
// }
  
  static setLexState (number: number) {
    Lexer.YYINITIAL = number;
  }
  
  static setIntervalLength (length: number) {
    Lexer.ZZ_INTERVAL_LENGTH = length;
  }
  
  static setBufferSize (bufferSize: number) {
    Lexer.ZZ_BUFFERSIZE = bufferSize;
    
  }
  
  /**
   * Closes the input stream.
   */
  public yyclose () {
    this.zzAtEOF = true;
    /* indicate end of file */
    this.zzEndRead = this.zzStartRead;
    /* invalidate buffer    */
    
    if (!isUndefined(this.zzReader)) {
      this.zzReader.close();
    }
  }
  
  /**
   * Resets the scanner to read from a new input stream.
   * Does not close the old reader.
   * <p>
   * All internal variables are reset, the old input stream
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>ZZ_INITIAL</tt>.
   *
   * @param reader the new input stream
   */
  public yyreset (reader: JavaFileReader) {
    this.zzReader = reader;
    this.zzAtBOL = true;
    this.zzAtEOF = false;
    this.zzEndRead = this.zzStartRead = 0;
    this.zzCurrentPos = this.zzMarkedPos = this.zzPushbackPos = 0;
    this.yyline = this.yychar = this.yycolumn = 0;
    this.zzLexicalState = Lexer.YYINITIAL;
  }
  
  /**
   * Returns the current lexical state.
   */
  public yystate (): number {
    return this.zzLexicalState;
  }
  
  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  public yybegin (newState: number) {
    this.zzLexicalState = newState;
  }
  
  /**
   * Returns the text matched by the current regular expression.
   */
  public yytext (): string {
    // return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);
    return this.zzBuffer.substr(this.zzStartRead, this.zzMarkedPos - this.zzStartRead);
  }
  
  /**
   * Returns the character at position <tt>pos</tt> from the
   * matched text.
   * <p>
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch.
   *            A value from 0 to yylength()-1.
   * @return the character at position pos
   */
  public yycharat (pos: number): string {
    return this.zzBuffer[this.zzStartRead + pos];
  }
  
  /**
   * Returns the length of the matched text region.
   */
  public yylength () {
    return this.zzMarkedPos - this.zzStartRead;
  }
  
  /**
   * Pushes the specified amount of characters back into the input stream.
   * <p>
   * They will be read again by then next call of the scanning method
   *
   * @param number the number of characters to be read again.
   *               This number must not be greater than yylength()!
   */
  public yypushback (number: number) {
    if (number > this.yylength()) {
      this.zzScanError(Lexer.ZZ_PUSHBACK_2BIG);
    }
    this.zzMarkedPos -= number;
  }
  
  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return the next token
   * @throws java.io.IOException if any I/O-Error occurs
   */
  public nextToken (): Token {
    let zzInput;
    let zzAction;
    
    // cached fields:
    let zzCurrentPosL;
    let zzMarkedPosL;
    let zzEndReadL = this.zzEndRead;
    let zzBufferL = this.zzBuffer;
    const zzCMapL = Lexer.ZZ_CMAP;
    
    const zzTransL = Lexer.ZZ_TRANS;
    const zzRowMapL = Lexer.ZZ_ROWMAP;
    const zzAttrL = Lexer.ZZ_ATTRIBUTE;
    
    while (true) {
      zzMarkedPosL = this.zzMarkedPos;
      
      let zzR = false;
      for (zzCurrentPosL = this.zzStartRead; zzCurrentPosL < zzMarkedPosL;
           zzCurrentPosL++) {
        switch (zzBufferL[zzCurrentPosL]) {
          case '\u000B':
          case '\u000C':
          case '\u0085':
          case '\u2028':
          case '\u2029':
            this.yyline++;
            this.yycolumn = 0;
            zzR = false;
            break;
          case '\r':
            this.yyline++;
            this.yycolumn = 0;
            zzR = true;
            break;
          case '\n':
            if (zzR) {
              zzR = false;
            } else {
              this.yyline++;
              this.yycolumn = 0;
            }
            break;
          default:
            zzR = false;
            this.yycolumn++;
        }
      }
      
      if (zzR) {
        // peek one character ahead if it is \n (if we have counted one line too much)
        let zzPeek = false;
        if (zzMarkedPosL < zzEndReadL) {
          zzPeek = zzBufferL[zzMarkedPosL] === '\n';
        } else if (this.zzAtEOF) {
          zzPeek = false;
        } else {
          const eof = this.zzRefill();
          zzMarkedPosL = this.zzMarkedPos;
          zzBufferL = this.zzBuffer;
          if (eof) {
            zzPeek = false;
          } else {
            zzPeek = zzBufferL[zzMarkedPosL] === '\n';
          }
        }
        if (zzPeek) {
          this.yyline--;
        }
      }
      zzAction = -1;
      
      zzCurrentPosL = this.zzCurrentPos = this.zzStartRead = zzMarkedPosL;
      
      this.zzState = this.zzLexicalState;
      
      
      zzForAction: {
        while (true) {
          
          if (zzCurrentPosL < zzEndReadL) {
            zzInput = zzBufferL[zzCurrentPosL++];
          } else if (this.zzAtEOF) {
            zzInput = Lexer.YYEOF;
            break zzForAction;
          } else {
            // store back cached positions
            this.zzCurrentPos = zzCurrentPosL;
            this.zzMarkedPos = zzMarkedPosL;
            const eof = this.zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL = this.zzCurrentPos;
            zzMarkedPosL = this.zzMarkedPos;
            zzBufferL = this.zzBuffer;
            zzEndReadL = this.zzEndRead;
            if (eof) {
              zzInput = Lexer.YYEOF;
              break zzForAction;
            } else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          const zzNext = zzTransL[zzRowMapL[this.zzState] + zzCMapL[zzInput]];
          if (zzNext === -1) {
            break zzForAction;
          }
          this.zzState = zzNext;
          
          const zzAttributes = zzAttrL[this.zzState];
          if ((zzAttributes & 1) === 1) {
            zzAction = this.zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ((zzAttributes & 8) === 8) {
              break zzForAction;
            }
          }
          
        }
      }
      
      // store back cached position
      this.zzMarkedPos = zzMarkedPosL;
      
      switch (zzAction < 0 ? zzAction : Lexer.ZZ_ACTION[zzAction]) {
        case 28: {
          return this.token(Type.TRUE);
        }
        case 39:
          break;
        case 29: {
          return this.token(Type.TYPE);
        }
        case 40:
          break;
        case 21: {
          return this.token(Type.IF);
        }
        case 41:
          break;
        case 30: {
          return this.token(Type.VOID);
        }
        case 42:
          break;
        case 27: {
          return this.token(Type.ELSE);
        }
        case 43:
          break;
        case 19: {
          return this.token(Type.TIMES);
        }
        case 44:
          break;
        case 38: {
          return this.token(Type.BOOLEAN);
        }
        case 45:
          break;
        case 36: {
          return this.token(Type.MODULE);
        }
        case 46:
          break;
        case 33: {
          return this.token(Type.WHILE);
        }
        case 47:
          break;
        case 31: {
          return this.token(Type.BREAK);
        }
        case 48:
          break;
        case 34: {
          return this.token(Type.RETURN);
        }
        case 49:
          break;
        case 4: {
          return this.token(Type.INT_LITERAL);
        }
        case 50:
          break;
        case 3: {
          return this.token(Type.ID);
        }
        case 51:
          break;
        case 1: {
          throw new Error('unexpected character \'' + this.yytext() + '\'');
        }
        case 52:
          break;
        case 7: {
          return this.token(Type.LCURLY);
        }
        case 53:
          break;
        case 24: {
          return this.token(Type.LEQ);
        }
        case 54:
          break;
        case 17: {
          return this.token(Type.MINUS);
        }
        case 55:
          break;
        case 35: {
          return this.token(Type.IMPORT);
        }
        case 56:
          break;
        case 8: {
          return this.token(Type.LPAREN);
        }
        case 57:
          break;
        case 6: {
          return this.token(Type.LBRACKET);
        }
        case 58:
          break;
        case 12: {
          return this.token(Type.SEMICOLON);
        }
        case 59:
          break;
        case 26: {
          return this.token(Type.INT);
        }
        case 60:
          break;
        case 5: {
          return this.token(Type.COMMA);
        }
        case 61:
          break;
        case 22: {
          return this.token(Type.EQEQ);
        }
        case 62:
          break;
        case 13: {
          return this.token(Type.DIV);
        }
        case 63:
          break;
        case 32: {
          return this.token(Type.FALSE);
        }
        case 64:
          break;
        case 15: {
          return this.token(Type.GT);
        }
        case 65:
          break;
        case 16: {
          return this.token(Type.LT);
        }
        case 66:
          break;
        case 20: {
          return this.token(Type.STRING_LITERAL, this.yytext());
        }
        case 67:
          break;
        case 23: {
          return this.token(Type.GEQ);
        }
        case 68:
          break;
        case 9: {
          return this.token(Type.RBRACKET);
        }
        case 69:
          break;
        case 14: {
          return this.token(Type.EQL);
        }
        case 70:
          break;
        case 10: {
          return this.token(Type.RCURLY);
        }
        case 71:
          break;
        case 25: {
          return this.token(Type.NEQ);
        }
        case 72:
          break;
        case 37: {
          return this.token(Type.PUBLIC);
        }
        case 73:
          break;
        case 11: {
          return this.token(Type.RPAREN);
        }
        case 74:
          break;
        case 18: {
          return this.token(Type.PLUS);
        }
        case 75:
          break;
        case 2:
        case 76:
          break;
        default:
          if (zzInput === Lexer.YYEOF && this.zzStartRead === this.zzCurrentPos) {
            this.zzAtEOF = true;
            {
              return this.token(Type.EOF);
            }
          } else {
            this.zzScanError(Lexer.ZZ_NO_MATCH);
          }
      }
    }
  }
  
  public token (type: Type, text?: string): Token {
    if (!text) {
      return this.constructor(type, this.yyline, this.yycolumn, this.yytext());
    } else {
      if (type === Type.STRING_LITERAL) {
        text = text.substring(1, text.length - 1);
      }
      return this.constructor(type, this.yyline, this.yycolumn, text);
    }
    
  }
  
  /**
   * Refills the input buffer.
   *
   * @return <code>false</code>, iff there was new input.
   * @throws java.io.IOException if any I/O-Error occurs
   */
  public zzRefill (): boolean {
    
    /* first: make room (if you can) */
    if (this.zzStartRead > 0) {
      if (this.zzStartRead > 0) {
        this.zzBuffer = this.zzBuffer.substring(this.zzStartRead, this.zzEndRead - this.zzStartRead);
        this.zzEndRead -= this.zzStartRead;
        this.zzCurrentPos -= this.zzStartRead;
        this.zzMarkedPos -= this.zzStartRead;
        this.zzPushbackPos -= this.zzStartRead;
        this.zzStartRead = 0;
      }
      
      if (this.zzCurrentPos >= Lexer.ZZ_BUFFERSIZE) {
        let newBuffer = '';
        newBuffer = this.zzBuffer.substring(0, Lexer.ZZ_BUFFERSIZE);
        this.zzBuffer = newBuffer;
      }
      
      
      const temp = this.zzReader.read(this.zzEndRead, Lexer.ZZ_BUFFERSIZE - this.zzEndRead);
      this.zzBuffer = temp[1];
      const numRead = temp[0];
      if (numRead < 0) {
        return true;
      } else {
        this.zzEndRead += numRead;
        return false;
      }
    }
  }
  
  /**
   * Reports an error that occured while scanning.
   * <p>
   * In a wellformed scanner (no or only correct usage of
   * yypushback(int) and a match-all fallback rule) this method
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   * <p>
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param errorCode the code of the errormessage to display
   */
  public zzScanError (errorCode: number) {
    let message = '';
    try {
      message = Lexer.ZZ_ERROR_MSG[errorCode];
    } catch (e) {
      message = Lexer.ZZ_ERROR_MSG[Lexer.ZZ_UNKNOWN_ERROR];
    }
    
    throw new Error(message);
  }
}
